---
eip: 0000
title: Block-Level Access Warming
description: Fair distribution of state warming costs across transactions using block access lists
author: Toni Wahrstätter (@nerolation)
discussions-to: https://ethereum-magicians.org/t/eip-xxxx-block-level-access-warming/
status: Draft
type: Standards Track
category: Core
created: 2025-08-05
requires: 7928, 2929
---

## Abstract

This EIP introduces a mechanism to distribute storage and account warming costs fairly across all transactions that access pre-warmed resources in a block. Using Block-Level Access Lists from [EIP-7928](./eip-7928.md), warming costs are calculated and split evenly among transactions that benefit from the warming, ensuring fair cost allocation.

## Motivation

[EIP-2929](./eip-2929.md) introduced cold/warm storage access pricing, where the first access to a storage slot or account costs significantly more than subsequent accesses. In the simplest form of block-level pre-warming, as proposed in [EIP-7862](./eip-7862.md) a fairness issue arises: the first transaction accessing a resource pays the full cold access cost while subsequent transactions benefit from warm access prices.
Furthermore, a fair distribution of access costs, as proposed in [EIP-7557](./eip-7557.md) usually relies on pre-charging cold costs and then reimbursing senders post-execution, and on [EIP-2930](./eip-2930.ms) Access Lists, which are unreliable in terms of correctness.

This proposal ensures that all transactions accessing a pre-warmed resource share the warming cost proportionally, enabling:

- Fair cost distribution
- Pre-execution split of warming costs
- Removal of first-mover disadvantage in transaction ordering
- Economic incentive alignment with actual resource usage

## Specification

### Overview

When a block contains a `block_access_list`, the warming costs for all accessed storage slots and accounts are:

1. Calculated based on which transactions access each resource
2. Distributed evenly among those transactions
3. Charged as an additional gas cost during transaction execution

### Constants

```python
# Warming costs (difference between cold and warm access)
STORAGE_WARMING_COST = 2100 - 100 = 2000  # GAS_COLD_SLOAD - GAS_WARM_ACCESS
ACCOUNT_WARMING_COST = 2600 - 100 = 2500  # GAS_COLD_ACCOUNT_ACCESS - GAS_WARM_ACCESS
```

### Block Processing Modifications

Modify the block processing to include warming cost calculation:

```python
def process_block_with_warming(block):
    # 1. Build warming cost tracker from BAL
    warming_tracker = build_warming_cost_tracker(block.block_access_list, len(block.transactions))
    
    # 2. Calculate total warming costs per address
    warming_costs = calculate_warming_costs(warming_tracker)
    
    # 3. Calculate per-transaction warming deltas
    tx_warming_deltas = calculate_transaction_warming_deltas(warming_tracker, warming_costs)
    
    # 4. Process transactions with warming deltas
    for i, tx in enumerate(block.transactions):
        warming_delta = tx_warming_deltas.get(i, 0)
        process_transaction_with_warming(tx, i, warming_delta)
```

### Warming Cost Tracking

The warming cost tracker maps resources to the transactions that access them:

```python
@dataclass
class WarmingCostTracker:
    # Maps (address, storage_key) to set of transaction indices that access it
    storage_access_map: Dict[Tuple[Address, Bytes32], Set[int]]
    # Maps address to set of transaction indices that access it
    account_access_map: Dict[Address, Set[int]]
```

Building the tracker from the Block Access List:

```python
def build_warming_cost_tracker(block_access_list: BlockAccessList, num_transactions: int) -> WarmingCostTracker:
    tracker = WarmingCostTracker()
    
    for account_changes in block_access_list.account_changes:
        address = account_changes.address
        
        # Track account accesses
        tx_indices = set()
        for change in account_changes.balance_changes:
            if change.tx_index < num_transactions:
                tx_indices.add(change.tx_index)
        for change in account_changes.nonce_changes:
            if change.tx_index < num_transactions:
                tx_indices.add(change.tx_index)
        for change in account_changes.code_changes:
            if change.tx_index < num_transactions:
                tx_indices.add(change.tx_index)
        for storage_change in account_changes.storage_changes:
            if storage_change.tx_index < num_transactions:
                tx_indices.add(storage_change.tx_index)
        
        if tx_indices:
            tracker.account_access_map[address] = tx_indices
        
        # Track storage slot accesses
        for slot_changes in account_changes.storage_changes:
            for change in slot_changes.changes:
                if change.tx_index < num_transactions:
                    key = (address, slot_changes.slot)
                    if key not in tracker.storage_access_map:
                        tracker.storage_access_map[key] = set()
                    tracker.storage_access_map[key].add(change.tx_index)
    
    return tracker
```

### Warming Cost Calculation

Calculate total warming costs:

```python
def calculate_warming_costs(tracker: WarmingCostTracker) -> Dict[Address, Uint]:
    warming_costs = {}
    
    # Add account warming costs
    for address in tracker.account_access_map:
        warming_costs[address] = warming_costs.get(address, 0) + ACCOUNT_WARMING_COST
    
    # Add storage warming costs
    for (address, _) in tracker.storage_access_map:
        warming_costs[address] = warming_costs.get(address, 0) + STORAGE_WARMING_COST
    
    return warming_costs
```

### Cost Distribution

Distribute warming costs evenly among accessing transactions:

```python
def calculate_transaction_warming_deltas(
    tracker: WarmingCostTracker,
    warming_costs: Dict[Address, Uint]
) -> Dict[int, Uint]:
    tx_warming_costs = {}
    
    # Distribute account warming costs
    for address, accessing_txs in tracker.account_access_map.items():
        if len(accessing_txs) > 0:
            cost_per_tx = ACCOUNT_WARMING_COST // len(accessing_txs)
            remainder = ACCOUNT_WARMING_COST % len(accessing_txs)
            
            for i, tx_idx in enumerate(sorted(accessing_txs)):
                tx_warming_costs[tx_idx] = tx_warming_costs.get(tx_idx, 0) + cost_per_tx
                # Distribute remainder to first transactions
                if i < remainder:
                    tx_warming_costs[tx_idx] += 1
    
    # Distribute storage warming costs
    for (address, storage_key), accessing_txs in tracker.storage_access_map.items():
        if len(accessing_txs) > 0:
            cost_per_tx = STORAGE_WARMING_COST // len(accessing_txs)
            remainder = STORAGE_WARMING_COST % len(accessing_txs)
            
            for i, tx_idx in enumerate(sorted(accessing_txs)):
                tx_warming_costs[tx_idx] = tx_warming_costs.get(tx_idx, 0) + cost_per_tx
                # Distribute remainder to first transactions
                if i < remainder:
                    tx_warming_costs[tx_idx] += 1
    
    return tx_warming_costs
```

### Transaction Execution
Toni Wahrstätter (@nerolation)
During transaction execution, the warming delta is applied:

```python
def process_transaction_with_warming(tx, tx_index, warming_delta):
    # Standard transaction validation and gas calculation
    sender = recover_sender(tx)
    intrinsic_gas = calculate_intrinsic_gas(tx)
    gas_fee = tx.gas_price * tx.gas_limit
    
    # Apply warming delta to sender's balance
    sender_balance = get_balance(sender)
    total_cost = gas_fee + tx.value + warming_delta
    
    if sender_balance < total_cost:
        raise InsufficientBalance()
    
    set_balance(sender, sender_balance - total_cost)
    
    # Execute transaction normally
    # All storage/account accesses will be warm due to pre-population
    execute_transaction(tx)
```

### Example

Consider a block with 3 transactions:
- Tx0: Accesses accounts A, B and storage slot (A, 0x01)
- Tx1: Accesses accounts B, C and storage slots (A, 0x01), (B, 0x02)
- Tx2: Accesses account C and storage slot (B, 0x02)

Warming costs:
- Account A: 2500 gas (accessed by Tx0)
- Account B: 2500 gas (accessed by Tx0, Tx1)
- Account C: 2500 gas (accessed by Tx1, Tx2)
- Storage (A, 0x01): 2000 gas (accessed by Tx0, Tx1)
- Storage (B, 0x02): 2000 gas (accessed by Tx1, Tx2)

Distribution:
- Tx0: 2500 (A) + 1250 (B/2) + 1000 ((A,0x01)/2) = 4750 gas
- Tx1: 1250 (B/2) + 1250 (C/2) + 1000 ((A,0x01)/2) + 1000 ((B,0x02)/2) = 4500 gas
- Tx2: 1250 (C/2) + 1000 ((B,0x02)/2) = 2250 gas

Total: 4750 + 4500 + 2250 = 11500 gas (matches total warming costs)

## Rationale

### Fair Cost Distribution

The even distribution ensures that all transactions benefiting from pre-warmed storage pay their fair share. This removes the disadvantage of being the first transaction to access a resource.

### Integration with EIP-7928

This proposal leverages the block access list to determine which transactions access which resources, enabling accurate cost distribution without additional data structures.

### No VM Changes Required

By charging warming costs during balance deduction, no changes to EVM opcodes or gas calculation logic are needed. The pre-warmed resources MUST be marked as accessed before execution begins.

### System Transaction Handling

System transactions (those with index >= transaction_count) are excluded from warming cost distribution as they represent protocol-level operations.

## Backwards Compatibility

This EIP requires a hard fork and is not backwards compatible. It must be activated alongside or after [EIP-7928](./eip-7928.md).

This EIP is backwards compatible in regard to transactions that were signed in the past since gas usage can only be reduced with the proposed change.

## Test Cases

### Test 1: Single Transaction
- Block with 1 transaction accessing storage slot S
- Expected: Transaction pays full warming cost of 2000 gas

### Test 2: Multiple Transactions, Same Slot
- Block with 3 transactions all accessing storage slot S
- Expected: Each transaction pays 667, 667, 666 gas respectively (2000/3 with remainder distribution)

### Test 3: Mixed Access Patterns
- Tx0: Accesses slots A, B
- Tx1: Accesses slots B, C
- Tx2: Accesses slot C
- Expected:
  - Tx0: 2000 (A) + 1000 (B/2) = 3000 gas
  - Tx1: 1000 (B/2) + 1000 (C/2) = 2000 gas
  - Tx2: 1000 (C/2) = 1000 gas

### Test 4: Account and Storage Warming
- Tx0: Accesses account A and storage (A, 0x01)
- Tx1: Accesses account A only
- Expected:
  - Tx0: 1250 (A/2) + 2000 (storage) = 3250 gas
  - Tx1: 1250 (A/2) = 1250 gas

## Security Considerations

### Balance Validation

Transactions must have sufficient balance to cover gas fees, value transfer, AND warming deltas. This validation occurs during transaction processing, not pre-flight, as balances may change during block execution. The proposed change can only lead to lower or equal gas used numbers for transactions.

### DOS Prevention

The warming cost distribution is deterministic and bounded by the actual cold access costs. Maximum additional cost per transaction is bounded by the number of unique resources it accesses multiplied by their respective warming costs.

### Fairness

The even distribution ensures no transaction can manipulate the system to avoid paying warming costs while benefiting from warm access prices.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
