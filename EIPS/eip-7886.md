---
eip: 7886
title: Delayed execution
description: Separate block validation from execution to enable validators to attest to blocks faster
author: Francesco D`Amato (@fradamt), Toni WahrstÃ¤tter (@nerolation)
discussions-to: https://ethereum-magicians.org/t/eip-7886-delayed-execution/22890
status: Draft
type: Standards Track
category: Core
created: 2025-02-18
requires: 1559, 2930, 4844, 7623
---

## Abstract

This proposal introduces a mechanism to make execution blocks statically verifiable through minimal checks that only require the previous state, without necessitating execution of the block's transactions. This enables validators to attest to a block's validity without completing its execution. 

## Motivation

The primary advantage of this proposal is the enablement of **asynchronous block validation**. In the current Ethereum protocol, blocks must be fully executed before validators can attest to their validity. This requirement creates a critical bottleneck in the consensus process, as attestors must wait for execution results before committing their votes, limiting the network's throughput potential.

By introducing a mechanism where execution payloads can be reverted rather than invalidating the entire block, execution is no longer an immediate requirement for validation. Instead, a block's validity can be determined based on its structural correctness and the upfront payment of transaction fees by senders. This allows attestation to happen earlier in the process, independent of execution, potentially enabling higher block gas limits and significant throughput improvements across the network.

## Specification

### Header Changes

The block header structure is extended to support delayed execution:

```python
@dataclass
class Header:
    # Existing fields
    parent_hash: Hash32
    ommers_hash: Hash32
    coinbase: Address
    
    # Pre-execution state root - this is the state root before executing transactions
    pre_state_root: Root
    
    # Transaction-related fields
    transactions_root: Root
    
    # Deferred execution outputs from parent block
    parent_receipt_root: Root  # Receipt root from parent block
    parent_bloom: Bloom       # Logs bloom from parent block
    
    # Other existing fields
    difficulty: Uint
    number: Uint
    gas_limit: Uint
    gas_used: Uint           # Declared gas used by txs, validated post-execution
    timestamp: U256
    extra_data: Bytes
    prev_randao: Bytes32
    nonce: Bytes8
    base_fee_per_gas: Uint
    withdrawals_root: Root
    blob_gas_used: U64
    excess_blob_gas: U64
    parent_beacon_block_root: Root
    parent_requests_hash: Hash32  # Hash of requests from the parent block
```

The key changes are:
1. `pre_state_root`: Represents the state root before execution (checked against parent block's post-execution state)
2. `parent_receipt_root`: Receipt root from the parent block (deferred execution output)
3. `parent_bloom`: Logs bloom from the parent block (deferred execution output)
4. `parent_requests_hash`: Hash of requests from the parent block (deferred execution output)

A block header MUST include all these fields to be considered valid under this EIP. The `pre_state_root` MUST match the state root after applying the parent block's execution. The parent execution outputs MUST accurately reflect the previous block's execution results to maintain chain integrity.

### Chain State Tracking

The blockchain object is extended to track execution outputs for verification in subsequent blocks:

```python
@dataclass
class BlockChain:
    blocks: List[Block]
    state: State
    chain_id: U64
    last_receipt_root: Root        # Receipt root from last executed block
    last_block_logs_bloom: Bloom   # Logs bloom from last executed block
    last_requests_hash: Bytes      # Requests hash from last executed block
```

These additional fields MUST be maintained by clients to verify the deferred execution outputs claimed in subsequent blocks. The `last_receipt_root`, `last_block_logs_bloom`, and `last_requests_hash` act as critical chain state references that MUST be updated after each successful block execution to ensure proper state progression.

### Block Validation

Static validation is performed separately from execution. In this phase, all checks that can be done without executing transactions are performed:

```python
def validate_block(chain: BlockChain, block: Block) -> Dict[Address, Uint]:
    # Validate header against parent
    validate_header(block.header, chain.blocks[-1].header)
    
    # Validate deferred execution outputs from the parent
    if block.header.parent_receipt_root != chain.last_receipt_root:
        raise InvalidBlock
    if block.header.parent_bloom != chain.last_block_logs_bloom:
        raise InvalidBlock
    if block.header.parent_requests_hash != chain.last_requests_hash:
        raise InvalidBlock
    if block.header.pre_state_root != state_root(chain.state):
        raise InvalidBlock
        
    ...
    
    # Validate all transactions and track sender balances
    sender_balances = {}
    sender_nonces = {}
    
    # Calculate total gas and blob gas
    total_inclusion_gas = Uint(0)
    total_blob_gas_used = Uint(0)
    
    # Process all transactions for validation
    for tx in transactions:
        # Validate transaction signature, limits, etc.
        sender_address = check_transaction(tx, chain_id, base_fee, excess_blob_gas)
        
        # Calculate gas costs
        inclusion_gas = calculate_inclusion_gas_cost(tx)
        blob_gas = calculate_total_blob_gas(tx)
        
        total_inclusion_gas += inclusion_gas
        total_blob_gas_used += blob_gas
        
        # Calculate maximum possible gas fee
        effective_gas_price = calculate_effective_gas_price(tx, base_fee)
        max_gas_fee = tx.gas * effective_gas_price + blob_gas * blob_gas_price
        
        # Track sender balance and nonce
        if sender_address not in sender_balances:
            account = get_account(chain.state, sender_address)
            # Ensure sender is an EOA
            if not is_sender_eoa(account):
                raise InvalidBlock
            sender_balances[sender_address] = account.balance
            sender_nonces[sender_address] = account.nonce
            
        # Ensure sender has enough balance for maximum fees
        if sender_balances[sender_address] < max_gas_fee + tx.value:
            raise InvalidBlock
            
        # Ensure nonce is correct
        if sender_nonces[sender_address] != tx.nonce:
            raise InvalidBlock
            
        # Deduct maximum fee from sender's tracked balance
        sender_balances[sender_address] -= max_gas_fee + tx.value
        sender_nonces[sender_address] += 1
    
    # Validate gas constraints
    if total_inclusion_gas > block.header.gas_used:
        raise InvalidBlock
    if block.header.gas_used > block.header.gas_limit:
        raise InvalidBlock
    if total_blob_gas_used > MAX_BLOB_GAS_PER_BLOCK:
        raise InvalidBlock

    # Return pre-validated sender balances for use during execution
    return sender_balances
```

This validation function enforces several requirements:

1. Clients MUST validate that the block's parent execution outputs match the chain's tracked last execution outputs.
2. The `pre_state_root` MUST match the current state root to ensure proper state transition.
3. All transactions MUST be statically validated for signature correctness and [EIP-2718](./eip-2718.md) transaction type specific requirements.
4. Sender accounts MUST be externally owned accounts (EOAs), not contracts.
5. Senders MUST have sufficient balance to cover maximum possible gas fees (as defined in [EIP-1559](./eip-1559.md)) plus transaction value.
6. Transaction nonces MUST be correct and sequential.
7. Total inclusion gas (calldata, [EIP-2930](./eip-2930.md) access lists and blobs) MUST not exceed the block gas limit.
8. Total gas used MUST NOT exceed the declared gas_used or block gas limit.
9. For blob transactions, total blob gas MUST NOT exceed the MAX_BLOB_GAS_PER_BLOCK limit as defined in [EIP-4844](./eip-4844.md).

This validation step ensures the block can be attested to without executing its transactions, as all structural and balance constraints are comprehensively checked.

### Block Execution with State Snapshots

After a block passes static validation, execution proceeds with the pre-charged transaction senders:

```python
def apply_body(
    ...
    block_gas_used: Uint,  # Declared gas used from header
    ...
    sender_balances: Dict[Address, Uint]  # Pre-validated sender balances
) -> ApplyBodyOutput:
    ...
    # Take a block-level snapshot of the state before transaction execution
    # This snapshot is separate from regular transaction snapshots
    begin_transaction(state)
    
    # Pre-charge senders by updating their balances based on pre-validation
    for sender, balance in sender_balances.items():
        sender_account = get_account(state, sender)
        set_account_balance(state, sender, U256(balance))
    
    # Execute all transactions
    for tx in transactions:
        sender_address = recover_sender(chain_id, tx)
        ...
        gas_used, logs, error = process_transaction(env, tx)
        total_gas_used += gas_used
        ...
    
    # Validate declared gas used against actual gas used
    # If there's a mismatch, revert the entire execution using the block-level snapshot
    if block_gas_used != total_gas_used:
        rollback_transaction(state)
        # Return empty execution outputs
        block_logs = ()
        requests_from_execution = []
        receipts_trie = Trie(secured=False, default=None)
    else:
        # Commit the execution if gas used matches declared value
        commit_transaction(state)
        # Process additional requests
        requests_from_execution = process_general_purpose_requests(
            deposit_requests, state, ...)
    
    # Process withdrawals
    ...
    
    # Calculate final execution outputs
    receipt_root = root(receipts_trie)
    block_logs_bloom = logs_bloom(block_logs)
    state_root = state_root(state)
    requests_hash = compute_requests_hash(requests_from_execution)
    
    return ApplyBodyOutput(
        receipt_root,
        block_logs_bloom,
        state_root,
        requests_hash
    )
```

During block execution:

1. Clients MUST create a block-level snapshot before any transaction execution occurs.
2. Sender balances MUST be pre-charged based on the values determined during static validation.
3. Transaction execution follows the existing rules without charging for transactions again.
4. After all transactions are executed, clients MUST verify that the actual gas used matches the declared gas_used in the block header.
5. If gas mismatch is detected, clients MUST roll back to a snapshot taken before the block execution and produce empty execution outputs.
6. If execution is valid, clients commit the execution and process any additional requests.
7. The execution outputs (receipt_root, logs_bloom, state_root, requests_hash) are calculated to ensure they can be verified in subsequent blocks.

The state management functions implement the critical block-level snapshot mechanism:

1. Clients MUST maintain separate block-level snapshots distinct from transaction-level snapshots.
2. The `begin_transaction` function MUST create a deep copy of the entire state trie and all storage tries.
3. When transient storage is present (as introduced in [EIP-1153](./eip-1153.md)), it MUST also be included in the block snapshot.
4. The `commit_transaction` function MUST clear the snapshot when execution is successful.
5. The `rollback_transaction` function MUST restore all state and storage tries to their pre-block values when execution is invalid.
6. After a rollback, any created accounts during the block execution MUST be cleared from the tracking set.


## Rationale

### Deferred Execution Outputs

The core innovation of deferring execution outputs to the next block enables static verification without requiring immediate execution. The `pre_state_root` provides a cryptographically verifiable starting point for validation, while parent execution outputs create a chain of deferred execution results that maintains the integrity of the blockchain state.

This approach eliminates the execution bottleneck in the validation pipeline by allowing validators to attest to a block's validity based on its structure and the pre-charged transaction fees, without waiting for execution results.

### Pre-Charging Mechanism

Pre-charging senders with the maximum possible fees before execution provides a crucial guarantee that transactions have sufficient balance to be included in the block. This mechanism is compatible with existing fee models, including [EIP-1559](./eip-1559.md) dynamic fee transactions and [EIP-4844](./eip-4844.md) blob transactions.

By tracking sender balances and nonces during validation, the protocol can enforce transaction validity without execution, enabling earlier block attestation.

### State Snapshot Architecture

The block-level snapshot mechanism builds upon the existing transaction snapshot system to provide an efficient way to revert execution when necessary. This approach allows clients to roll back the entire block's execution if the actual gas used does not match the declared gas in the header, without invalidating the block structure itself.

This provides two key benefits:
1. It allows validators to attest to blocks before execution is complete
2. It ensures execution is eventually performed correctly, with economic penalties for incorrect gas declarations

## Backwards Compatibility

This EIP requires a hard fork, as it alters the block validation and execution process.

## Security Considerations

### Execution Correctness Guarantees

The protocol ensures execution correctness through two primary mechanisms:

1. Deferred execution outputs MUST match in subsequent blocks, creating a chain of verifiable execution results
2. State rollback MUST occur if the actual gas used doesn't match the declared value, providing an economic incentive for correct gas declaration

### Data Availability and Economic Incentives

Block proposers MUST declare correct gas usage or lose transaction fees when execution is rolled back. This aligns incentives for correct gas declaration and ensures execution integrity.

Even when a block's execution is reverted due to incorrect gas declaration, the transaction data (calldata, [EIP-2930](./eip-2930.md) access lists, and blob data) MUST still be stored by all nodes for syncing and block validation purposes. This requirement creates a potential attack vector where malicious actors could attempt to place large amounts of data on-chain at a reduced cost by intentionally invalidating blocks through incorrect gas declarations.

However, this attack is not economically sustainable for several reasons:

1. Block proposers who invalidate blocks through incorrect gas declarations lose all execution layer rewards associated with the block.
2. The attack requires control of block production, which is a scarce resource in the consensus layer.

The economic costs of forgoing block rewards significantly outweigh any potential benefits, making such attacks financially impractical under normal network conditions.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
