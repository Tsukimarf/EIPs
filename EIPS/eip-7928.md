---
eip: 7928
title: Transaction-Level State Diff
description: Transaction-level state diffs with balance, code, and nonce changes
author: Toni Wahrst√§tter (@nerolation), Dankrad Feist (@dankrad), Francesco D`Amato (@fradamt), Jochem Brouwer (@jochem-brouwer), Ignacio Hagopian (@jsign)
discussions-to: https://ethereum-magicians.org/t/eip-7928-block-level-access-lists/23337
status: Draft
type: Standards Track
category: Core
created: 2025-03-31
---

## Abstract

This EIP introduces Transaction-Level State Diffs (TLSDs), which provide a comprehensive record of balance changes, code deployments, and nonce modifications during a block. By making this information explicit, TLSDs enable executionless state updates and accelerate block validation, potentially allowing for higher gas limits in the future and laying important groundwork for zkEVM full nodes.

## Motivation

Current block validation requires full transaction execution to determine state changes, including balance transfers, contract deployments, and nonce updates. This sequential processing creates bottlenecks in block validation and state synchronization.

We propose including explicit state diffs at the block level, shifting the responsibility of their creation to the block builder. This enables nodes to reconstruct state without processing all transactions, verifying correctness by comparing the derived state root to the head block's state root.

TLSDs include balance, code and nonce diffs for all affected accounts. This approach facilitates executionless state updates and improves overall network performance by reducing the computational burden on validators.

## Specification

### Block Structure Modification

We introduce a new field to the block header:

```python
class Header:
    # Existing fields
    ...
    
    state_diff_hash: Hash32
```

We introduce three new components in the block body:

1. Balance Diffs that track every address touched by value transfers along with the balance deltas.
2. Code Diffs that track every address and the deployed code to it.
3. Nonce Diffs that record the pre-block nonces of contracts using `CREATE` or `CREATE2` within the block.

### SSZ Data Structures

```python
# Type aliases
Address = ByteVector(20)
StorageKey = ByteVector(32)
StorageValue = ByteVector(32)
CodeData = ByteVector(MAX_CODE_SIZE)
TxIndex = uint16
Nonce = uint64

# Constants; chosen to support a 630m block gas limit
MAX_TXS = 30_000
MAX_SLOTS = 300_000
MAX_ACCOUNTS = 300_000
MAX_CODE_SIZE = 24_576  # Maximum contract bytecode size in bytes

# SSZ containers
class PerTxAccess(Container):
    tx_index: TxIndex
    value_after: StorageValue # value in state after the last access

class SlotAccess(Container):
    slot: StorageKey
    accesses: List[PerTxAccess, MAX_TXS] # empty for reads

class AccountAccess(Container):
    address: Address
    accesses: List[SlotAccess, MAX_SLOTS]

AccountAccessList = List[AccountAccess, MAX_ACCOUNTS]

# Balance Diff structures
BalanceDelta = ByteVector(12)  # signed, two's complement encoding

class BalanceChange(Container):
    tx_index: TxIndex
    delta: BalanceDelta  # signed integer, encoded as 12-byte vector

class AccountBalanceDiff(Container):
    address: Address
    changes: List[BalanceChange, MAX_TXS]

BalanceDiffs = List[AccountBalanceDiff, MAX_ACCOUNTS]

# Code Diff structures
class CodeChange(Container):
    tx_index: TxIndex
    new_code: CodeData # runtime bytecode of newly deployed contract

class AccountCodeDiff(Container):
    address: Address
    change: CodeChange

CodeDiffs = List[AccountCodeDiff, MAX_ACCOUNTS]

# Nonce Diff structures
class AccountNonce(Container):
    address: Address  # account address
    nonce_before: Nonce  # nonce value before transaction execution

NonceDiffs = List[AccountNonce, MAX_TXS]

# Transaction-level State Diff structure  
class TransactionLevelStateDiff(Container):
    account_accesses: AccountAccessList
    balance_diffs: BalanceDiffs
    code_diffs: CodeDiffs
    nonce_diffs: NonceDiffs
```

The `AccountAccessList` is a deduplicated list of addresses with storage writes. For each address, it MUST contain a list of written storage keys.

Addresses and storage keys MUST be ordered lexicographically. Transaction indices MUST be ordered in ascending order.

Each `SlotAccess` MUST contain an ordered list of transaction indices that wrote to this key, and the final storage value after the last write. Only storage writes are included; read-only accesses are not tracked.

The `BalanceDiffs` structure tracks every address with a balance change, including transaction senders, recipients, and the block's coinbase address. Touched accounts without balance changes MUST be omitted.
Each entry MUST include the transaction index and the signed balance delta per address for each transaction.
12 bytes are sufficient to represent the total ETH supply.

The `CodeDiff` structure tracks every deployed/changed contract with it's post-transaction runtime byte code.
Each entry MUST include the transaction index and the contract bytecode for each transaction with a contract deployment.

The `NonceDiffs` structure MUST record the pre-transaction nonce values for all `CREATE` and `CREATE2` deployer accounts and the deployed contracts in the block. This includes nonce increases that occur at the deployer contract even when deployments using `CREATE` or `CREATE2` revert, as specified in [EIP-7610](./eip-7610.md).

### State Transition Function

Modify the state transition function to validate the block-level access lists:

```python 
def state_transition(block):
    computed_access_list = {}
    computed_balance_diffs = {}
    computed_code_diffs = {}
    computed_nonce_diffs = {}

    for idx, tx in enumerate(block.transactions):
        # Record nonce before execution for all CREATE/CREATE2-related accounts
        nonce_info = get_nonce_info(tx)
        for address, nonce in nonce_info:
            if address not in computed_nonce_diffs:
                computed_nonce_diffs[address] = nonce

        # Execute transaction and collect state accesses and diffs
        accessed, balances, codes = execute_transaction(tx)

        for (addr, slot, is_write, value) in accessed:
            if is_write:  # Only track writes, ignore reads
                key = (addr, slot)
                if key not in computed_access_list:
                    computed_access_list[key] = []
                computed_access_list[key].append((idx, value))

        for (addr, delta) in balances:
            computed_balance_diffs.setdefault(addr, []).append((idx, delta))

        for (addr, code) in codes:
            computed_code_diffs.setdefault(addr, []).append((idx, code))

    # Validate block data
    assert block.state_diff.account_accesses == computed_access_list
    assert block.state_diff.balance_diffs == computed_balance_diffs
    assert block.state_diff.code_diffs == computed_code_diffs
    assert block.state_diff.nonce_diffs == computed_nonce_diffs
```

The TLSD MUST be complete and accurate. It MUST NOT contain too few entries (missing writes) or too many entries (spurious writes). Any missing or extra entries in the storage writes, balance diffs, or nonce diffs MUST result in block invalidation.

Client implementations MUST compare the storage writes and state changes gathered during execution with those included in the TLSD to determine validity.

Client implementations MAY invalidate the block right away in case any transaction produces state changes not declared in the TLSD.

## Test Cases

This section provides concrete test cases demonstrating various aspects of Transaction-Level State Diffs (TLSDs) using illustrative scenarios.

### Test Case 1: Simple Storage Write

**Scenario**: A transaction modifies a single storage slot.

**Input**:
```
Transaction Index: 0
Address: 0x1234567890123456789012345678901234567890
Storage Slot: 0x0000000000000000000000000000000000000000000000000000000000000001
Pre-execution Value: 0x0000000000000000000000000000000000000000000000000000000000000000
Post-execution Value: 0x000000000000000000000000000000000000000000000000000000000000007b
```

**Expected TLSD Entry**:
```python
AccountAccess(
    address=0x1234567890123456789012345678901234567890,
    accesses=[
        SlotAccess(
            slot=0x0000000000000000000000000000000000000000000000000000000000000001,
            accesses=[
                PerTxAccess(
                    tx_index=0,
                    value_after=0x000000000000000000000000000000000000000000000000000000000000007b
                )
            ]
        )
    ]
)
```

### Test Case 2: Multiple Transactions Accessing Same Slot

**Scenario**: Two transactions in the same block modify the same storage slot.

**Input**:
```
Transaction 0:
  Address: 0x1234567890123456789012345678901234567890
  Slot: 0x0000000000000000000000000000000000000000000000000000000000000001
  Value after: 0x000000000000000000000000000000000000000000000000000000000000007b

Transaction 2:
  Address: 0x1234567890123456789012345678901234567890
  Slot: 0x0000000000000000000000000000000000000000000000000000000000000001
  Value after: 0x00000000000000000000000000000000000000000000000000000000000000ff
```

**Expected TLSD Entry**:
```python
AccountAccess(
    address=0x1234567890123456789012345678901234567890,
    accesses=[
        SlotAccess(
            slot=0x0000000000000000000000000000000000000000000000000000000000000001,
            accesses=[
                PerTxAccess(tx_index=0, value_after=0x000000000000000000000000000000000000000000000000000000000000007b),
                PerTxAccess(tx_index=2, value_after=0x00000000000000000000000000000000000000000000000000000000000000ff)
            ]
        )
    ]
)
```


### Test Case 4: Balance Changes

**Scenario**: ETH transfers and fee payments.

**Input**:
```
Transaction 0: Transfer 0.5 ETH from sender to recipient
  Sender: 0xa1b2c3d4e5f6789012345678901234567890abcd
  Recipient: 0xfedcba0987654321098765432109876543210fed
  Gas Fee: 0.001 ETH to coinbase

Transaction 1: Contract interaction with gas fee
  Sender: 0x1111222233334444555566667777888899990000
  Gas Fee: 0.0015 ETH to coinbase
```

**Expected Balance Diff Entries**:
```python
[
    AccountBalanceDiff(
        address=0xa1b2c3d4e5f6789012345678901234567890abcd,
        changes=[
            BalanceChange(tx_index=0, delta=-500001000000000000)  # -0.500001 ETH (transfer + gas)
        ]
    ),
    AccountBalanceDiff(
        address=0xfedcba0987654321098765432109876543210fed,
        changes=[
            BalanceChange(tx_index=0, delta=500000000000000000)   # +0.5 ETH received
        ]
    ),
    AccountBalanceDiff(
        address=0x1111222233334444555566667777888899990000,
        changes=[
            BalanceChange(tx_index=1, delta=-1500000000000000)    # -0.0015 ETH gas fee
        ]
    ),
    AccountBalanceDiff(
        address=0x0123456789abcdef0123456789abcdef01234567,  # coinbase
        changes=[
            BalanceChange(tx_index=0, delta=1000000000000000),    # +0.001 ETH
            BalanceChange(tx_index=1, delta=1500000000000000)     # +0.0015 ETH
        ]
    )
]
```

### Test Case 5: Contract Deployment

**Scenario**: A contract deployment via CREATE opcode.

**Input**:
```
Transaction Index: 3
Deployer Address: 0x1234567890123456789012345678901234567890
Deployed Contract: 0x9876543210987654321098765432109876543210
Runtime Bytecode: 0x608060405234801561001057600080fd5b50...
Pre-deployment Nonce: 5
Post-deployment Nonce: 6
```

**Expected Code Diff Entry**:
```python
AccountCodeDiff(
    address=0x9876543210987654321098765432109876543210,
    changes=[
        CodeChange(
            tx_index=3,
            new_code=0x608060405234801561001057600080fd5b50...
        )
    ]
)
```

**Expected Nonce Diff Entry**:
```python
AccountNonceDiff(
    address=0x1234567890123456789012345678901234567890,
    changes=[
        NonceChange(tx_index=3, nonce=5)  # Pre-deployment nonce
    ]
)
```

### Test Case 6: CREATE2 Deployment with Salt

**Scenario**: A contract deployment using CREATE2 with deterministic address.

**Input**:
```
Transaction Index: 5
Factory Contract: 0xabcdef1234567890abcdef1234567890abcdef12
Deployed Address: 0x4321098765432109876543210987654321098765
Salt: 0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef
Runtime Bytecode: 0x6080604052348015...
Factory Pre-nonce: 12
Factory Post-nonce: 13
```

**Expected Entries**:
```python
# Code diff for the newly deployed contract
AccountCodeDiff(
    address=0x4321098765432109876543210987654321098765,
    changes=[
        CodeChange(tx_index=5, new_code=0x6080604052348015...)
    ]
)

# Nonce diff for the factory contract
AccountNonceDiff(
    address=0xabcdef1234567890abcdef1234567890abcdef12,
    changes=[
        NonceChange(tx_index=5, nonce=12)
    ]
)
```

### Test Case 7: Complex Multi-Transaction Scenario

**Scenario**: A complete block with multiple transaction types.

**Block Header**:
```
Transaction Count: 4
State Diff Hash: 0x123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef01
```

**Expected Complete TransactionLevelStateDiff Structure**:
```python
TransactionLevelStateDiff(
    account_accesses=[
        AccountAccess(
            address=0x1234567890123456789012345678901234567890,
            accesses=[
                SlotAccess(
                    slot=0x0000000000000000000000000000000000000000000000000000000000000001,
                    accesses=[PerTxAccess(tx_index=0, value_after=0x000000000000000000000000000000000000000000000000000000000000007b)]
                )
            ]
        )
    ],
    balance_diffs=[
        AccountBalanceDiff(
            address=0xa1b2c3d4e5f6789012345678901234567890abcd,
            changes=[BalanceChange(tx_index=0, delta=-500001000000000000)]
        ),
        AccountBalanceDiff(
            address=0xfedcba0987654321098765432109876543210fed,
            changes=[BalanceChange(tx_index=0, delta=500000000000000000)]
        )
    ],
    code_diffs=[
        AccountCodeDiff(
            address=0x9876543210987654321098765432109876543210,
            changes=[CodeChange(tx_index=3, new_code=0x608060405234801561001057600080fd5b50...)]
        )
    ],
    nonce_diffs=[
        AccountNonceDiff(
            address=0x1234567890123456789012345678901234567890,
            changes=[NonceChange(tx_index=3, nonce=5)]
        )
    ]
)
```

### Test Case 8: Validation Failure Cases

**Invalid Case 1 - Missing Storage Write**:
```
Block contains transaction that writes to slot 0x01 but TLSD omits this entry.
Expected Result: Block validation MUST fail.
```

**Invalid Case 2 - Extra Storage Write**:
```
TLSD contains entry for slot 0x02 but no transaction actually wrote to it.
Expected Result: Block validation MUST fail.
```

**Invalid Case 3 - Incorrect Post-Write Value**:
```
Transaction writes 0x123 to slot but TLSD claims value_after is 0x456.
Expected Result: Block validation MUST fail.
```

**Invalid Case 4 - Missing Balance Change**:
```
Transaction transfers ETH but balance diff omits sender's balance decrease.
Expected Result: Block validation MUST fail.
```

### Test Case 9: Ordering Requirements

**Input with Incorrect Ordering**:
```python
# Addresses MUST be ordered lexicographically
account_accesses = [
    AccountAccess(address=0xffff..., ...),  # Should be last
    AccountAccess(address=0x0000..., ...)   # Should be first
]
```

**Expected Result**: Block validation MUST fail due to incorrect address ordering.

**Correct Ordering**:
```python
account_accesses = [
    AccountAccess(address=0x0000..., ...),  # Lexicographically first
    AccountAccess(address=0xffff..., ...)   # Lexicographically last
]
```

### Test Case 10: Edge Cases

**Empty Block**:
```python
TransactionLevelStateDiff(
    account_accesses=[],
    balance_diffs=[],      # Only coinbase reward
    code_diffs=[],
    nonce_diffs=[]
)
```

**Maximum Size Block**:
```
Worst-case TLSD with 300,000 account accesses, each with 300,000 slot writes.
Expected compressed size: ~0.93 MiB (within acceptable limits)
```

These test cases demonstrate the complete functionality of EIP-7928 Transaction-Level State Diffs, covering storage write operations, balance changes, contract deployments, nonce tracking, validation requirements, and edge cases. Implementations MUST pass all positive test cases and MUST reject all negative test cases to be considered compliant.

## Rationale

### TLSD Design Choice

This design variant was chosen for several key reasons:

1. **Focus on state changes**: TLSDs track only storage writes, balance changes, code deployments, and nonce updates - the essential state modifications needed for state reconstruction. By excluding read-only operations, the size is significantly reduced while maintaining all information needed for executionless state updates.

2. **Storage value inclusion for writes**: Including post-execution values for write operations facilitates state reconstruction during syncing, enabling faster chain catch-up. Unlike snap sync, state updates in TLSDs are not individually proved against the state root. Similar to snap sync, execution itself is not proven. However, validators can verify correctness by comparing the final state root with the one received from a light node for the head block.

3. **Balance and nonce tracking**: Balance diffs and nonce tracking are crucial for correct handling of parallel transaction execution. While most nonce updates can be anticipated statically (based on sender accounts), contract creation operations (`CREATE` and `CREATE2`) can increase an account's nonce without that account appearing as a sender. The nonce diff structure specifically addresses this edge case by tracking nonces for contract deployers and deployed contracts. For changing delegation under [EIP-7702](./eip-7702.md), the transaction type indicates that an `authority`'s nonce must be updated.

4. **Reasonable overhead with significant benefits**: Analysis of historical blocks (random sample of 1000 blocks between 22,195,599 and 22,236,441) shows that TLSDs would have had an average size of around 40 KiB, with balance diffs adding only 9.6 KiB on average. This represents a reasonable overhead given the substantial performance benefits in block validation time.

5. **Simplified validation**: By focusing only on state modifications rather than all accesses, the validation logic is simplified while still providing complete information for state reconstruction and verification.

### Block Size Considerations

Including state diffs increases block size, potentially impacting network propagation times and blockchain liveness. Based on analysis of historical blocks:

- Average TLSD size over 1,000 blocks was around 40 KiB (SSZ-encoded, snappy compressed)
- Average balance diff size was approximately 9.6 KiB
- Worst-case TLSD size for consuming the entire block gas limit (36m) with storage write operations would be approximately 0.93 MiB (this is smaller than worst-case calldata blocks and both are mutually exclusive)
- Worst-case balance diff size would be around 0.12 MiB

These sizes are manageable and less than the current worst-case block size achievable through calldata.

### Asynchronous Validation

Block validation can be optimized through executionless state updates, with verification of the state diff occurring alongside state reconstruction, ensuring correctness without requiring full transaction execution.

## Backwards Compatibility

This proposal requires changes to the block structure that are not backwards compatible and require a hard fork.

## Security Considerations

### Validation Overhead

Validating state diffs and balance changes adds validation overhead but is essential to prevent acceptance of invalid blocks.

### Block Size

Including comprehensive state diffs, balance changes and nonce values increases block size, potentially impacting network propagation times. However, as noted in the rationale section, the overhead is reasonable given the performance benefits, with typical TLSDs averaging around 67 KiB in total.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
